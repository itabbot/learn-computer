# AMQP<!-- omit in toc -->

- [1. 快速开始](#1-快速开始)
  - [1.1. 相关资源](#11-相关资源)
  - [1.2. 定义](#12-定义)
  - [1.3. 背景](#13-背景)
  - [1.4. 应用场景](#14-应用场景)
  - [1.5. 尝试](#15-尝试)
- [2. 按需学习](#2-按需学习)
- [3. 系统学习](#3-系统学习)

## 1. 快速开始

### 1.1. 相关资源

[官方网站](https://www.amqp.org) | [协议下载](https://www.amqp.org/resources/download) | [典型实现](https://www.amqp.org/about/examples)

### 1.2. 定义

AMQP，英文全称 Advanced Message Queuing Protocol，即 “高级消息队列协议”，它是一种面向消息中间件的、开放的、标准化的应用层协议，用于在应用程序之间传递消息。有以下特点：

- 可靠性（Reliability）： AMQP 提供了可靠的消息传递机制。它确保消息的可靠传输，包括消息的持久化、确认机制和错误处理。AMQP 可以保证消息在发送方和接收方之间的可靠传递，即使在网络故障或系统故障的情况下也能保持数据的完整性和一致性。
- 灵活性（Flexibility）： AMQP 具有灵活的消息路由和传递模型。它支持多种交换机类型（如直连交换机、扇形交换机、主题交换机等），可以根据消息的路由键、标签和属性等进行灵活的消息路由和过滤。这使得 AMQP 能够适应各种复杂的消息通信场景。
- 互操作性（Interoperability）： AMQP 是一个开放的、标准化的协议，得到了广泛的支持和应用。它提供了与不同厂商和实现之间的互操作性，使得不同的 AMQP 实现可以相互通信和交换消息。这样可以构建跨平台、跨语言和跨技术栈的分布式系统，实现系统之间的集成和通信。
- 扩展性（Scalability）： AMQP 具有良好的扩展性，可以处理大规模的消息流量和高并发的消息传递。它支持消息的异步传递和并行处理，可以构建高性能、高吞吐量的消息传递系统。AMQP 的扩展性使得它适用于各种规模和复杂度的应用场景。
- 安全性（Security）： AMQP 提供了安全的消息传递机制。它支持消息的加密、身份验证和访问控制，保护消息的机密性和完整性。AMQP 可以在消息的传输和存储过程中提供安全保障，确保消息只被授权的实体访问和处理。
- 可观察性（Observability）： AMQP 支持监控和追踪消息的流动和处理过程。它提供了丰富的元数据和指标，可以用于监测消息的传递延迟、丢失率和处理吞吐量等性能指标。这对于分析和优化消息传递系统非常有价值。
- 异步通信（Asynchronous Communication）： AMQP 支持异步通信模式，其中消息的发送和接收是非阻塞的。生产者可以异步地将消息发送到 AMQP 系统，而消费者可以异步地接收和处理消息。这种异步通信模式提供了更高的并发性和可伸缩性。
- 可扩展的消息模型（Extensible Message Model）： AMQP 提供了灵活的消息模型，支持不同类型的消息结构和协议操作。它允许开发者定义自定义的消息格式和协议扩展，以满足特定的业务需求和应用场景。
- 消息事务（Message Transactions）： AMQP 支持消息事务，允许生产者发送一系列相关的消息作为一个事务单元。这样可以确保这些消息要么全部成功传递，要么全部失败，从而保持数据的一致性和完整性。

以下是 AMQP 的一些基本概念：

- 生产者（Producer）： 生产者是消息的发送者，负责创建消息并将其发送到 AMQP 消息代理（Broker）。
- 代理（Broker）： AMQP 消息代理是消息传递的中间件，负责接收、存储和路由消息，将消息从生产者传递给消费者。
- 消费者（Consumer）： 消费者是消息的接收者，负责从 AMQP 消息代理获取消息并进行处理。
- 消息（Message）： 消息是 AMQP 中的基本单位，它包含要传递的数据和相关的元数据。消息可以是任意格式的数据，如文本、二进制数据或结构化数据。每条消息都有唯一的标识符（Message ID）。
- 消息属性（Properties）： 消息的属性是与消息关联的元数据，用于描述消息的特性和行为。属性包括消息的优先级、时间戳、过期时间、消息类型、回复地址等信息。
- 消息标签（Headers）： 标签是一组以键值对形式表示的消息头信息。标签可以包含任意的自定义信息，用于扩展消息的附加属性。
- 路由键（Routing Key）： 路由键是生产者在发送消息时指定的一个值，用于将消息路由到正确的目标队列。交换机根据路由键将消息分发到相应的队列。
- 交换机（Exchange）： 交换机消息代理中消息的接收者，负责接收生产者发送的消息，并根据路由键将消息分发到相应的队列。交换机可以根据不同的路由策略将消息广播到多个队列或选择性地将消息发送到特定队列。
- 队列（Queue）： 队列是消息的存储和分发单元，用于暂时存储生产者发送的消息。消费者可以从队列中接收消息并进行处理。
- 绑定（Binding）： 绑定是交换机和队列之间的关联关系，定义了消息从交换机路由到特定队列的规则。
- 频道（Channel）： AMQP 使用频道作为消息传输的通道，客户端可以在单个连接上创建多个通道，每个通道相互独立。
- 虚拟主机（Virtual Host）： 虚拟主机是 AMQP 消息代理上的逻辑隔离单元，每个虚拟主机具有自己的队列、交换机和权限控制。

### 1.3. 背景

发展历程

- 创建： AMQP 于 2003 年由伦敦摩根大通（一家美国跨国金融服务公司）的 John O'Hara 创立。初始设计方案在 2004 年中至 2006 年中由摩根大通发布，由 iMatix 公司编写协议文档和一个 C 语言实现。
- 成立工作组： 2005 年摩根大通推动了包括 Cisco Systems、IONA Technologies、iMatix、Red Hat 和 TWIST 等公司组成了一个工作组（后续发展到二十多家公司）。
- 多家公司实现： 同年摩根大通与 Red Hat 公司合作开发了 Apache Qpid，该实现最初由 Java 编写，后转向 C++。
  此外，Rabbit 技术公司独立用 Erlang 开发了 RabbitMQ，并于 2007 年发布了第一个版本。随后也有包括微软、StormMQ 等多家公司实现了 AMQP。
- 早期版本： 早期的协议版本包括 0-8（2006 年 6 月发布）、0-9（2006 年 12 月发布）、0-9-1（2008 年 11 月发布）。这些版本与后来的 1.0 系列**有很大的不同**。
- 1.0 国际标准版本： 2011 年 8 月，高级消息队列协议工作组公布其改组方案，作为 OASIS 成员运作。高级消息队列协议 1.0 版本在 2011 年 10 月 30 日发表。该版本在 2014 年四月成为 ISO/IEC 国际标准。

### 1.4. 应用场景

AMQP（准确来说应该是 AMQP 的实现）有以下应用场景：

- 解耦和提高系统响应性： AMQP 可以实现系统之间的异步通信，允许发送方将消息发送到中间件，而不需要等待接收方的即时响应。这在需要解耦和提高系统响应性的情况下非常有用。
- 事件驱动架构： 消息中间件可以用作事件驱动架构的基础。应用程序可以通过发布和订阅消息的方式进行事件通信，以实现松耦合、可扩展和可靠的系统架构。
- 分布式系统集成： 消息中间件用于实现不同分布式系统之间的集成和通信。通过发送和接收消息，系统可以实现数据共享、协调和协作，从而构建灵活和可扩展的分布式系统。
- 扩展性和负载均衡： 消息中间件可以作为负载均衡和扩展性的解决方案。它可以将请求分发到多个消费者，实现水平扩展，并确保负载均衡和高可用性。
- 队列和任务调度： 消息中间件可以用作队列和任务调度的解决方案。应用程序可以将任务发送到中间件的队列中，然后由消费者逐个处理任务。这在需要控制任务执行顺序和优先级的情况下非常有用。

相对于其他消息中间件，实现了 AMQP 的中间件更适用于：

- 复杂路由和消息处理需求： AMQP 具有灵活的消息路由和消息过滤机制，使得消息可以被动态地路由到不同的消费者或处理器。这对于具有复杂路由规则和多级处理逻辑的应用场景非常有用，如发布-订阅模式、消息转发和消息路由器等。
- 跨平台和异构系统集成： AMQP 的设计目标之一是提供跨平台和异构系统的互操作性。它定义了一个标准的消息格式和协议，使得不同的应用和系统可以使用不同的编程语言和平台进行集成和通信。因此，如果您的应用需要与多种不同技术栈的系统进行集成，AMQP 可以提供更好的灵活性和互操作性。
- 可靠性和持久性要求高的场景： AMQP 提供了可靠的消息传递机制，支持消息的持久化和持久化队列。这对于需要确保消息不会丢失，并且在系统故障或重启后仍然可用的应用场景非常重要，如金融交易、订单处理等。
- 高性能和可扩展性要求： AMQP 协议被设计为高性能和可扩展的，能够处理大量的消息和高并发的请求。这使得它适用于需要处理大规模数据流和高吞吐量的应用场景，如实时数据处理、物联网等。

### 1.5. 尝试

体验 AMQP 的前提是选择一个 AMQP 的实现。参见 [RabbitMQ>>](../../../software-engineering/backend-dev/RabbitMQ#15-尝试)

## 2. 按需学习

## 3. 系统学习
