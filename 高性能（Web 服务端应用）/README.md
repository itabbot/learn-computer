# 高性能（Web 服务端应用）<!-- omit in toc -->

相对于普通的软件系统（Web 服务端应用），高性能软件系统的处理能力更强、处理效率更高、占用的资源更少。通常表现在完成其自身功能的及时性上。

高性能的软件系统，有些是一开始的时候就被设计为高性能，而还有很大一部分软件系统，其性能是随着业务的不断发展壮大而逐渐优化提高的。这取决于该软件系统的实际业务目标、业务场景，以及开发资源的投入情况等等。

# 目录<!-- omit in toc -->

- [1. 性能指标](#1-性能指标)
  - [1.1. 吞吐量](#11-吞吐量)
  - [1.2. 交易响应时间](#12-交易响应时间)
  - [1.3. 错误率](#13-错误率)
  - [1.4. 并发用户](#14-并发用户)
- [2. 影响因素](#2-影响因素)
  - [2.1. 服务器](#21-服务器)
    - [2.1.1. CPU](#211-cpu)
    - [2.1.2. Memory](#212-memory)
    - [2.1.3. 磁盘吞吐量](#213-磁盘吞吐量)
    - [2.1.4. 网络吞吐量](#214-网络吞吐量)
    - [2.1.5. 内核参数](#215-内核参数)
  - [2.2. 数据库](#22-数据库)
    - [2.2.1. MySQL](#221-mysql)
    - [2.2.2. Redis](#222-redis)
    - [2.2.3. MongoDB](#223-mongodb)
    - [2.2.4. Elasticsearch](#224-elasticsearch)
  - [2.4. 网络接入层](#24-网络接入层)
  - [2.3. 应用程序](#23-应用程序)
  - [2.5. 消息队列](#25-消息队列)

## 1. 性能指标

软件系统的性能，通过以下各项指标来衡量，可以对软件系统进行 [性能测试](../性能测试) 来获得这些指标。高性能的软件系统在这些指标的表现上都会非常的出色。

### 1.1. 吞吐量

吞吐量指标体现了系统的处理能力，指系统在利用系统硬件平台和软件平台进行信息处理的能力，通过系统每秒钟能够处理的交易数量来评价。通常会有以下细分指标：

- TPS（Transaction per Second）：系统每秒处理交易数，单位是笔/秒。
- QPS（Query per Second）：系统每秒处理查询次数，单位是次/秒。
- HPS（Hits Per Second）：每秒点击次数，单位是次/秒。

无论 TPS、QPS 或 HPS，此指标是衡量系统处理能力非常重要的指标，越大越好，一般情况下：

- 金融行业：1000 TPS ~ 50000 TPS，不包括互联网化的活动。
- 保险行业：100 TPS ~ 100000 TPS，不包括互联网化的活动。
- 制造行业：10 TPS ~ 5000 TPS。
- 互联网电子商务：10000 TPS ~ 1000000 TPS。
- 互联网中型网站：1000 TPS ~ 50000 TPS。
- 互联网小型网站：500 TPS ~ 10000 TPS。

### 1.2. 交易响应时间

响应时间（英文：Response Time, RT），指用户从客户端发起一个请求开始，到客户端接收到从服务器端返回的响应结束，整个过程所耗费的时间。单位一般为秒或毫秒。一般而言，**交易响应时间**均指平均响应时间，指系统稳定运行的某个时间段内，同一交易的平均响应时间。

不同行业不同业务可接受的响应时间是不同的，一般情况，对于在线实时交易：

- 互联网企业：500 毫秒以下。
- 金融企业：1 秒以下为佳，部分复杂业务 3 秒以下。
- 保险企业：3 秒以下为佳。
- 制造业：5 秒以下为佳。

### 1.3. 错误率

错误率指系统在负载情况下，失败交易的概率。错误率 = ( 失败交易数 / 交易总数 ) × 100%。

不同系统对错误率的要求不同，但一般不超出千分之六，即成功率不低于 99.4%。稳定性较好的系统，其错误率应该由超时引起，即为超时率。

### 1.4. 并发用户

并发用户数指在同一时刻内，登录系统并进行业务操作的用户数量。

除了使用长连接的系统之外，系统处理能力并不受并发用户数影响。通常是使用吞吐量指标来衡量系统的处理能力。

## 2. 影响因素

一个 Web 服务端应用软件系统，通常由[应用程序](#23-应用程序)和各类组件构成，组件包括（但不限于）[网络接入组件](#24-网络接入层)、[数据库]()、[消息队列](#25-消息队列)等等。每一个组成部分自身的表现，都可能会影响到整体的性能，而其中的短板往往就是软件系统整体性能的瓶颈。就像 “木桶原理” 所说的：一只木桶盛水的多少，并不取决于桶壁上最高的那块木块，而恰恰取决于桶壁上最短的那块。

软件系统的每个组成部分，都是运行在具体的物理[服务器](#21-服务器)之上的，所以服务器的各项指标会直接影响到软件系统的性能。

### 2.1. 服务器

服务器的能力可以通过以下各项指标来衡量。还可以考虑集群部署，通过负载均衡提高整体性能。

#### 2.1.1. CPU

CPU 是指 “中央处理器”，英文全称 Central Processing Unit。它是一块超大规模的集成电路，是一台计算机的运算核心（Core）和控制核心（Control Unit）。它的功能主要是解释计算机指令以及处理计算机软件中的数据。相关的指标有：

- 系统平均负载（CPU Load）：一般要求小于 CPU 的核数值。
- 使用率：业界警戒值为 75%。CPU 资源利用率很高的话，需要看 CPU 消耗哪种状态。
- 用户态（user）：如果 CPU User 非常高，需要查看消耗在哪个进程，可以用 top（linux）命令看出，接着用 `top –H –p <pid>` 看哪个线程消耗资源高。如果是 Java 应用，就可以用 jstack 看出此线程正在执行的堆栈，看资源消耗在哪个方法上，查看源代码就知道问题所在；如果是 c++应用，可以用 gprof 性能工具进行分析。
- 系统态（sys）：一般要求小于或者等于 30%。如果 CPU Sys 非常高，可以用 strace（linux）看系统调用的资源消耗及时间。
- 等待态（wait）：一般要求小于或者等于 5%。如果 CPU Wait 非常高，考虑磁盘读写了，可以通过减少日志输出、异步或换速度快的硬盘。

#### 2.1.2. Memory

内存（英文：Memory）是计算机中重要的部件之一，它是与 CPU 进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。

现代的操作系统为了最大利用内存，在内存中存放了缓存，因此内存利用率 100% 并不代表内存有瓶颈，衡量系统内存有瓶颈主要靠 SWAP（与虚拟内存交换）交换空间利用率，一般情况下，SWAP 交换空间利用率要低于 70%，太多的交换将会引起系统性能低下。

#### 2.1.3. 磁盘吞吐量

磁盘吞吐量（英文：Disk Throughput）是指在无磁盘故障的情况下单位时间内通过磁盘的数据量。

磁盘指标主要有：每秒读写多少兆、磁盘繁忙率、磁盘队列数、平均服务时间、平均等待时间、空间利用率等。其中**磁盘繁忙率**是直接反映磁盘是否有瓶颈的重要依据，一般情况下，磁盘繁忙率要低于 70%。可以通过减少日志输出、异步或换速度快的硬盘来降低繁忙率。

#### 2.1.4. 网络吞吐量

网络吞吐量（英文：Network Throughput）是指在无网络故障的情况下单位时间内通过的网络的数据数量，单位为 Byte/s。

网络吞吐量指标用于衡量系统对于网络设备或链路传输能力的需求。当网络吞吐量指标接近网络设备或链路最大传输能力时，则需要考虑升级网络设备。网络吞吐量指标主要有每秒有多少兆流量进出，一般情况下不能超过设备或链路最大传输能力的 70%。主要考虑传输内容大小，不能超过硬件网络传输的最大值 70%，可以通过压缩减少内容大小、在本地设置缓存以及分多次传输等操作提高网络 I/O 性能。

#### 2.1.5. 内核参数

操作系统内核参数主要包括信号量、进程、文件句柄等，一般都有默认值，这些内核参数默认值对于一般系统没问题，但是对于对性能要求搞的软件系统来说，可能运行的参数将会超过内核参数，导致系统出现问题，可以用 sysctl 来查看及修改。

| 指标            | 单位 | 解释                                                   |
| --------------- | :--: | ------------------------------------------------------ |
| Maxuprc         |  个  | 限制每个用户的用户进程的最大数量                       |
| Max_thread_proc |  个  | 定义每个进程允许的最大线程数量                         |
| Filecache_max   | 字节 | 最大可用于 cache file I/O 的物理内存                   |
| Ninode          |  个  | 内存中 HFS 文件系统打开 i 节点的最大数量               |
| Nkthread        |  个  | 限制允许同时运行的线程数量                             |
| Nproc           |  个  | 限制允许同时运行的进程数量                             |
| Nstrpty         |  个  | 基于 STREAMS 的伪终端 （pts） 的最大数量               |
| Maxdsiz         | 字节 | 任何用户进程的数据段的最大大小（以字节为单位）         |
| maxdsiz_64bit   | 字节 | 任何用户进程的数据段的最大大小（以字节为单位）         |
| maxfiles_lim    |  个  | 每个进程的文件描述符的最大数目硬限制                   |
| maxssiz_64bit   | 字节 | 任何用户进程的堆栈的最大大小                           |
| Maxtsiz         | 字节 | 任一用户进程的文本段的最大大小                         |
| nflocks         |  个  | 文件锁的最大数量                                       |
| maxtsiz_64bit   | 字节 | 任一用户进程的文本段的最大大小                         |
| msgmni          |  个  | 系统级 System V IPC 消息队列 （ID) 所允许的最大数量    |
| msgtql          |  个  | 系统中任意时间的最大 System V IPC 消息数               |
| npty            |  个  | BSD 伪终端 （pty） 的最大数量                          |
| nstrtel         |  个  | 指定内核可支持传入 telnet 会话的 telnet 设备文件的数量 |
| nswapdev        |  个  | 可用于交换的设备的最大数量                             |
| nswapfs         |  个  | 可用于交换的文件系统的最大数量                         |
| semmni          |  个  | System V IPC 系统级信号量标识符的数量                  |
| semmns          |  个  | System V 系统级信号量的数量                            |
| shmmax          | 字节 | System V 共享内存段的最大大小                          |
| shmmni          |  个  | 系统中 System V 共享内存段标识符的数量                 |
| shmseg          |  个  | 每个进程 System V 共享内存段的最大数量                 |

### 2.2. 数据库

所有的数据库都需要运行在具体的服务器之上，所以，除了数据库系统本身的各项指标之外，承载它的服务器的指标也会影响到其表现的性能。以下是常用的数据库系统：

#### 2.2.1. MySQL

MySQL 的指标主要包括：

| 一级指标 | 二级指标             | 单位   | 解释                |
| -------- | -------------------- | ------ | ------------------- |
| SQL      | 耗时                 | 微秒   | 执行 SQL 耗时       |
| 吞吐量   | QPS                  | 个     | 每秒查询次数        |
| 吞吐量   | TPS                  | 个     | 每秒事务次数        |
| 命中率   | Key Buffer 命中率    | 百分之 | 索引缓冲区命中率    |
| 命中率   | InnoDB Buffer 命中率 | 百分之 | InnoDB 缓冲区命中率 |
| 命中率   | Query Cache 命中率   | 百分之 | 查询缓存命中率      |
| 命中率   | Table Cache 命中率   | 百分之 | 表缓存命中率        |
| 命中率   | Thread Cache 命中率  | 百分之 | 线程缓存命中率      |
| 锁       | 等待次数             | 次     | 锁等待次数          |
| 锁       | 等待时间             | 微秒   | 锁等待时间          |

一般来说：

- SQL 耗时越小越好，一般情况下微秒级别。
- 命中率越高越好，一般情况下不能低于 95%。
- 锁等待次数越低越好，等待时间越短越好。

优化方法：

- 读写分离。
- 分库分表和索引优化。
- 借助搜索引擎解决复杂查询问题。
- 解决慢查询：SQL 效率低下也是导致性能差的一个非常重要的原因，一般情况下 SQL 效率低下原因如下表所示。

| 类别   | 子类                        | 表达式或描述                                             | 原因                                                                    |
| ------ | --------------------------- | -------------------------------------------------------- | ----------------------------------------------------------------------- |
| 索引   | 未建索引                    | 无                                                       | 产生全表扫描                                                            |
| 索引   | 未利用索引                  | substring(card_no,1,4)=′5378′                            | 产生全表扫描                                                            |
| 索引   | 未利用索引                  | amount/30< 1000                                          | 产生全表扫描                                                            |
| 索引   | 未利用索引                  | convert(char(10),date,112)=′19991201′                    | 产生全表扫描                                                            |
| 索引   | 未利用索引                  | where salary<>3000                                       | 产生全表扫描                                                            |
| 索引   | 未利用索引                  | name like '%张'                                          | 产生全表扫描                                                            |
| 索引   | 未利用索引                  | first_name + last_name ='beill cliton'                   | 产生全表扫描                                                            |
| 索引   | 未利用索引                  | id_no in(′0′,′1′)                                        | 产生全表扫描                                                            |
| 索引   | 未利用索引                  | select id from t where num=@num                          | 有参数也会产生全表扫描                                                  |
| 索引   | 使用效能低的索引            | oder by 非聚簇索引                                       | 索引性能低                                                              |
| 索引   | 使用效能低的索引            | username='张三'and age>20                                | 字符串索引低于整形索引                                                  |
| 索引   | 使用效能低的索引            | 表中列与空 NULL 值                                       | 索引性能低                                                              |
| 索引   | 使用效能低的索引            | 尽量不要使用 IS NULL 或 IS NOT NULL                      | 索引性能低                                                              |
| 数据量 | 所有数据量                  | select \*                                                | 很多列产生大量数据                                                      |
| 数据量 | 所有数据量                  | select id,name                                           | 表中有几百万行，产生大量数据                                            |
| 数据量 | 嵌套查询                    | 先不过滤数据，后过滤数据                                 | 产生大量无用的数据                                                      |
| 数据量 | 关联查询                    | 多表进行关联查询，先过滤掉小部分数据，在过滤大部分数据   | 大量关联操作                                                            |
| 数据量 | 大数据量插入                | 一次次插入                                               | 产生大量日志，消耗资源                                                  |
| 锁     | 锁等待                      | update account set banlance=100 where id=10              | 产生表级锁，将会锁住整个表                                              |
| 锁     | 死锁                        | A:update a;update b;B:update b;update a;                 | 将会产生死锁                                                            |
| 锁     | 游标                        | Cursor Open cursor,fetch;close cursor                    | 性能很低                                                                |
| 锁     | 临时表                      | create tmp table 创建临时表                              | 产生大量日志                                                            |
| 锁     | drop table                  | 删除临时表                                               | 需要显示删除，避免系统表长时间锁定                                      |
| 其他   | exist 代替 IN               | select num from a where num in(select num from b)        | in 会逐个判断，exist 有一条就结束                                       |
| 其他   | exist 代替 select count(\*) | 判断记录是否存在                                         | count(\*) 将累加计算，exist 有就结束                                    |
| 其他   | between 代替 IN             | ID in(1,2,3)                                             | IN 逐个判断，between 是范围判断                                         |
| 其他   | left outer join 代替 Not IN | select ID from a where ID not in(select b.Mainid from b) | NOT IN 逐个判断，效率非常低                                             |
| 其他   | union all 代替 union        | select ID from a union select id from b union            | 删除重复的行，可能会在磁盘进行排序而 union all 只是简单的将结果并在一起 |
| 其他   | 常用 SQL 尽量用绑定变量方法 | insert into A(ID) values(1)                              | 直接写 SQL 每次都要编译，用绑定变量的方法只编译一次，下次就可以用了     |

#### 2.2.2. Redis

待补充。

#### 2.2.3. MongoDB

待补充。

#### 2.2.4. Elasticsearch

待补充。

### 2.4. 网络接入层

很多情况下系统流量并没有完全进入到服务端，在网络接入层（比如：负载均衡、防火墙、高防 IP，甚至是 CDN 或全站加速等）可能就会出现由于各种规格限制（比如：带宽、最大连接数、新建连接数等）或防护策略不当导致性能不佳。

这部分通常都是成熟的组件，没有定制化的程序开发，所以一般是规格或配置问题。比如带宽的规格不够、动态负载均衡器的分发机制设置不当等。相应的调整规活配置即可改善性能。

### 2.3. 应用程序

在程序开发过程中，需要留意开发的功能是否会影响到系统整体的性能，将隐患扼杀在摇篮之中。常见的性能隐患及其解决方法：

- 任务处理耗时较长：异步化，通过多线程、MQ、甚至延时任务进行异步处理。
- 峰值流量巨增：
  - 对流量进行削峰填谷，通过 MQ 承接流量。
  - 限流，需要先考虑业务是否允许限流（比如秒杀场景是允许的），包括前端限流、Nginx 接入层的限流、服务端的限流。
- 网络 IO 繁忙：
  - 减少 IO 次数，比如数据库和缓存的批量读写、RPC 的批量接口支持、或者通过冗余数据的方式干掉 RPC 调用。
  - 减少 IO 时的数据包大小，包括采用轻量级的通信协议、合适的数据结构、去掉接口中的多余字段、减少缓存 key 的大小、压缩缓存 value 等。
- 集中式活动场景下计算量巨大
  - 预计算，比如抢红包场景，可以提前计算好红包金额缓存起来，发红包时直接使用即可。
  - 缓存预热，通过异步任务提前预热数据到本地缓存或者分布式缓存中。
- 低消算法:
  - 并发处理，通过多线程将串行逻辑并行化。
  - 大概率阻断执行流程的判断逻辑前置、For 循环的计算逻辑优化，或者采用更高效的算法。

### 2.5. 消息队列

比如 Rabbit、Kafka 等等。

任何消息队列其本质都是程序，都需要运行在具体的服务器之上，所以，除了本身的各项指标之外，承载它的服务器的指标也会影响到其表现的性能。
